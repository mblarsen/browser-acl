{"version":3,"file":"index.module.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * Disable all 'smarts' and require you to be explicit.\n */\nexport interface Options {\n  strict?: boolean\n}\n\n/**\n * Something that possibly has a beforeAll and otherwise\n * just a string-access.\n */\nexport interface Policy {\n  beforeAll?: Function\n  [key: string]: any\n}\n\n/**\n * Verbs or action: view, edit, delete, restore, etc.\n */\nexport type Verb = string\n\n/**\n * The object of the verb. E.g. in the sentence: 'user edits post' here\n * 'post' is the verb object.\n */\nexport type VerbObject = string | Function | object\n\n/**\n * A callback with determines of a user can perform an action\n */\nexport type TestFunction = (user?: any, ...args: any[]) => boolean\n\n/**\n * The test for allowing the user to perform action\n */\nexport type Test = boolean | TestFunction\n\ntype VerbObjectName = string | undefined\n\ntype VerbObjectOrTest = VerbObject | boolean\n\nconst assumeGlobal = (obj: any): boolean =>\n  typeof obj === 'boolean' ||\n  typeof obj === 'undefined' ||\n  (typeof obj === 'function' && obj.name === '')\n\n/**\n * Simple ACL library for the browser inspired by Laravel's guards and policies.\n *\n * Examples:\n *\n * ```javascript\n * acl.rule('create', Post)\n * acl.rule('edit', Post, (user, post) => post.userId === user.id)\n * ```\n */\nclass Acl {\n  static GlobalRule = 'GLOBAL_RULE'\n\n  strict: boolean\n  rules: Map<VerbObjectName, { [key: string]: Test }>\n  policies: Map<VerbObjectName | undefined, Policy>\n  registry: WeakMap<Object, string>\n\n  /**\n   * browser-acl\n   *\n   * @access public\n   */\n  constructor({ strict = false }: Options = {}) {\n    this.strict = strict\n    this.rules = new Map()\n    this.policies = new Map()\n    this.registry = new WeakMap()\n  }\n\n  /**\n   * You add rules by providing a verb, a verb object and an optional\n   * test (that otherwise defaults to true).\n   *\n   * If the test is a function it will be evaluated with the params:\n   * user, verbObject, and verbObjectName. The test value is ultimately evaluated\n   * for truthiness.\n   *\n   * Examples:\n   *\n   * ```javascript\n   * acl.rule('create', Post)\n   * acl.rule('edit', Post, (user, post) => post.userId === user.id)\n   * acl.rule('edit', Post, (user, post, verb, additionalParameter, secondAdditionalParameter) => true)\n   * acl.rule('delete', Post, false) // deleting disabled\n   * acl.rule('purgeInactive', user => user.isAdmin) // global rule\n   * ```\n   *\n   * @access public\n   */\n  rule(verbs: Verb | Verb[], verbObject: VerbObjectOrTest, test: Test = true) {\n    let verbObject_: VerbObject\n    if (assumeGlobal(verbObject)) {\n      test = typeof verbObject === 'undefined' ? true : (verbObject as Test)\n      verbObject_ = Acl.GlobalRule\n    } else {\n      verbObject_ = verbObject as VerbObject\n    }\n    const verbObjectName = this.verbObjectMapper(verbObject_)\n    const verbs_ = Array.isArray(verbs) ? verbs : [verbs]\n    verbs_.forEach((verb) => {\n      const rules = this.rules.get(verbObjectName) || {}\n      rules[verb] = test\n      this.rules.set(verbObjectName, rules)\n    })\n    return this\n  }\n\n  /**\n   * You can group related rules into policies for a verb object. The policies\n   * properties are verbs and they can plain values or functions.\n   *\n   * If the policy is a function it will be new'ed up before use.\n   *\n   * ```javascript\n   *   class Post {\n   *     constructor() {\n   *       this.view = true       // no need for a functon\n   *       this.delete = false    // not really necessary since an abscent\n   *                              // verb has the same result\n   *     }\n   *     beforeAll(verb, user, ...theRest) {\n   *       if (user.isAdmin) {\n   *         return true\n   *       }\n   *       // return nothing (undefined) to pass it on to the other rules\n   *     }\n   *     edit(user, post, verb, additionalParameter, secondAdditionalParameter) {\n   *       return post.id === user.id\n   *     }\n   *   }\n   * ```\n   *\n   * Policies are useful for grouping rules and adding more complex logic.\n   *\n   * @access public\n   */\n  policy(policy: Policy, verbObject: VerbObject) {\n    const policy_ =\n      typeof policy === 'function' ? new (policy as any)() : policy\n    const verbObjectName = this.verbObjectMapper(verbObject)\n    this.policies.set(verbObjectName, policy_)\n    return this\n  }\n\n  /**\n   * Explicitly map a class or constructor function to a name.\n   *\n   * You would want to do this in case your code is heavily\n   * minified in which case the default mapper cannot use the\n   * simple \"reflection\" to resolve the verb object name.\n   *\n   * Note: If you override the verbObjectMapper this is not used,\n   * bud it can be used manually through `this.registry`.\n   *\n   * @access public\n   */\n  register(klass: Function, verbObjectName: string) {\n    this.registry.set(klass, verbObjectName)\n    return this\n  }\n\n  /**\n   * Performs a test if a user can perform action on verb object.\n   *\n   * The action is a verb and the verb object can be anything the\n   * verbObjectMapper can map to a verb object name.\n   *\n   * E.g. if you can to test if a user can delete a post you would\n   * pass the actual post. Where as if you are testing us a user\n   * can create a post you would pass the class function or a\n   * string.\n   *\n   * ```javascript\n   *   acl.can(user, 'create', Post)\n   *   acl.can(user, 'edit', post)\n   *   acl.can(user, 'edit', post, additionalParameter, secondAdditionalParameter)\n   * ```\n   *\n   * Note that these are also available on the user if you've used\n   * the mixin:\n   *\n   * ```javascript\n   *   user.can('create', Post)\n   *   user.can('edit', post)\n   * ```\n   *\n   * @access public\n   */\n  can(\n    user: Object,\n    verb: Verb,\n    verbObject: VerbObject | undefined = undefined,\n    ...args: any[]\n  ) {\n    verbObject = typeof verbObject === 'undefined' ? Acl.GlobalRule : verbObject\n    const verbObjectName = this.verbObjectMapper(verbObject)\n\n    const policy = this.policies.get(verbObjectName)\n    const rules = policy || this.rules.get(verbObjectName)\n\n    if (typeof rules === 'undefined') {\n      if (this.strict) {\n        throw new Error(`No rules for verb object \"${verbObjectName}\"`)\n      }\n      return false\n    }\n\n    if (policy && typeof policy.beforeAll === 'function') {\n      const result = policy.beforeAll(\n        verb,\n        user,\n        verbObject,\n        verbObjectName,\n        ...args,\n      )\n      if (typeof result !== 'undefined') {\n        return result\n      }\n    }\n\n    if (typeof rules[verb] === 'function') {\n      return Boolean(rules[verb](user, verbObject, verbObjectName, ...args))\n    }\n\n    if (this.strict && typeof rules[verb] === 'undefined') {\n      throw new Error(`Unknown verb \"${verb}\"`)\n    }\n\n    return Boolean(rules[verb])\n  }\n\n  /**\n   * Like can but verb object is an array where only some has to be\n   * true for the rule to match.\n   *\n   * Note the verb objects do not need to be of the same kind.\n   *\n   * @access public\n   */\n  some(user: object, verb: Verb, verbObjects: VerbObject[], ...args: any[]) {\n    return verbObjects.some((s) => this.can(user, verb, s, ...args))\n  }\n\n  /**\n   * Like can but verbObject is an array where all has to be\n   * true for the rule to match.\n   *\n   * Note the verb objects do not need to be of the same kind.\n   *\n   * @access public\n   */\n  every(user: Object, verb: Verb, verbObjects: VerbObject[], ...args: any[]) {\n    return verbObjects.every((s) => this.can(user, verb, s, ...args))\n  }\n\n  /**\n   * Mix in augments your user class with a `can` function object. This\n   * is optional and you can always call `can` directly on your\n   * Acl instance.\n   *\n   * ```\n   * user.can()\n   * user.can.some()\n   * user.can.every()\n   * ```\n   *\n   * @access public\n   */\n  mixin(User: Function) {\n    const acl = this\n    User.prototype.can = function (\n      verb: Verb,\n      verbObject: VerbObject,\n      ...args: any[]\n    ) {\n      return acl.can(this, verb, verbObject, ...args)\n    }\n    User.prototype.can.every = function (\n      verb: Verb,\n      verbObjects: VerbObject[],\n      ...args: any[]\n    ) {\n      return acl.every(this, verb, verbObjects, ...args)\n    }\n    User.prototype.can.some = function (\n      verb: Verb,\n      verbObjects: VerbObject[],\n      ...args: any[]\n    ) {\n      return acl.some(this, verb, verbObjects, ...args)\n    }\n    return this\n  }\n\n  /**\n   * Rules are grouped by verb objects and this default mapper tries to\n   * map any non falsy input to a verb object name.\n   *\n   * This is important when you want to try a verb against a rule\n   * passing in an instance of a class.\n   *\n   * - strings becomes verb objects\n   * - function's names are used for verb object\n   * - object's constructor name is used for verb object\n   *\n   * Override this function if your models do not match this approach.\n   *\n   * E.g. say that you are using plain data objects with a type property\n   * to indicate the type of the object.\n   *\n   * ```javascript\n   *   acl.verbObjectMapper = s => typeof s === 'string' ? s : s.type\n   * ```\n   *\n   * `can` will now use this function when you pass in your objects.\n   *\n   * ```javascript\n   * acl.rule('edit', 'book', (user, book) => user.id === book.authorId)\n   * const thing = {title: 'The Silmarillion', authorId: 1, type: 'book'}\n   * acl.can(user, 'edit', thing)\n   * ```\n   *\n   * In the example above the 'thing' will follow the rules for 'book'. The\n   * user can edit the book if they are the author.\n   *\n   * See {@link #register register()} for how to manually map\n   * classes to verb object name.\n   *\n   * @access public\n   */\n  verbObjectMapper(verbObject: VerbObject): VerbObjectName {\n    if (typeof verbObject === 'string') {\n      return verbObject\n    }\n    if (this.registry.has(verbObject)) {\n      return this.registry.get(verbObject)\n    }\n    if (this.registry.has(verbObject.constructor)) {\n      return this.registry.get(verbObject.constructor)\n    }\n    if (typeof verbObject === 'function') {\n      return verbObject.name\n    }\n    return verbObject.constructor.name\n  }\n\n  /**\n   * Removes all rules, policies, and registrations\n   */\n  reset() {\n    this.rules = new Map()\n    this.policies = new Map()\n    this.registry = new WeakMap()\n    return this\n  }\n\n  /**\n   * Remove rules for verb object\n   *\n   * Optionally limit to a single verb.\n   */\n  removeRules(verbObject: VerbObject, verb: Verb | null = null) {\n    const verbObjectName = this.verbObjectMapper(verbObject)\n    if (this.rules.has(verbObjectName)) {\n      if (verb) {\n        const rules = this.rules.get(verbObjectName)\n        if (rules) {\n          delete rules[verb]\n        }\n        return this\n      }\n      this.rules.delete(verbObjectName)\n    }\n    return this\n  }\n\n  /**\n   * Remove policy for verb object\n   */\n  removePolicy(verbObject: VerbObject) {\n    const verbObjectName = this.verbObjectMapper(verbObject)\n    this.policies.delete(verbObjectName)\n    return this\n  }\n\n  /**\n   * Convenience method for removing all rules and policies for a verb object\n   */\n  removeAll(verbObject: VerbObject) {\n    this.removeRules(verbObject)\n    this.removePolicy(verbObject)\n    return this\n  }\n}\n\nexport default Acl\n"],"names":["Acl","strict","this","rules","Map","policies","registry","WeakMap","rule","verbs","verbObject","test","verbObject_","obj","name","GlobalRule","verbObjectName","verbObjectMapper","Array","isArray","forEach","verb","_this","get","set","policy","policy_","register","klass","can","user","undefined","args","Error","beforeAll","result","Boolean","some","verbObjects","s","_this2","every","_this3","mixin","User","acl","prototype","has","constructor","reset","removeRules","delete","removePolicy","removeAll"],"mappings":"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"}